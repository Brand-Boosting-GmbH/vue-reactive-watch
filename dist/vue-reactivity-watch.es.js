const t=()=>{},e=Object.assign,n=Array.isArray,o=t=>"function"==typeof t,c=t=>null!==t&&"object"==typeof t;function r(t,e){(e=e||undefined)&&e.active&&e.effects.push(t)}const i=t=>(t.w&l)>0,s=t=>(t.n&l)>0;let f=0,l=1;const u=[];let a;class h{constructor(t,e=null,n){this.fn=t,this.scheduler=e,this.active=!0,this.deps=[],r(this,n)}run(){if(!this.active)return this.fn();if(!u.includes(this))try{return u.push(a=this),l=1<<++f,f<=30?(({deps:t})=>{if(t.length)for(let e=0;e<t.length;e++)t[e].w|=l})(this):p(this),this.fn()}finally{f<=30&&(t=>{const{deps:e}=t;if(e.length){let n=0;for(let o=0;o<e.length;o++){const c=e[o];i(c)&&!s(c)?c.delete(t):e[n++]=c,c.w&=~l,c.n&=~l}e.length=n}})(this),l=1<<--f,u.pop();const t=u.length;a=t>0?u[t-1]:void 0}}stop(){this.active&&(p(this),this.onStop&&this.onStop(),this.active=!1)}}function p(t){const{deps:e}=t;if(e.length){for(let n=0;n<e.length;n++)e[n].delete(t);e.length=0}}function d(t){return function(t){return!(!t||!t.__v_isReadonly)}(t)?d(t.__v_raw):!(!t||!t.__v_isReactive)}function v(t){return Boolean(t&&!0===t.__v_isRef)}function g(t,e,n){let o;try{o=n?t(...n):t()}catch(c){y(c,e)}return o}function w(t,e,n){if(o(t)){const i=g(t,e,n);return i&&(c(r=i)&&o(r.then)&&o(r.catch))&&i.catch((t=>{y(t,e)})),i}var r;const i=[];for(let o=0;o<t.length;o++)i.push(w(t[o],e,n));return i}function y(t,e){console.error(new Error(`[@vue-reactivity/watch]: ${e}`)),console.error(t)}function _(t){console.warn(function(t){return new Error(`[reactivue]: ${t}`)}(t))}new Set(Object.getOwnPropertyNames(Symbol).map((t=>Symbol[t])).filter((t=>"symbol"==typeof t))),Promise.resolve();const b=t=>t(),m={};function S(t,e){return k(t,null,e)}function j(t,e,n){return k(t,e,n)}function k(c,i,{immediate:s,deep:f,onTrack:l,onTrigger:u}={}){let a,p;if(n(c)&&!d(c)?a=()=>c.map((t=>v(t)?t.value:d(t)?O(t):o(t)?g(t,"watch getter"):void _("invalid source"))):v(c)?a=()=>c.value:d(c)?(a=()=>c,f=!0):a=o(c)?i?()=>g(c,"watch getter"):()=>(p&&p(),g(c,"watch callback",[y])):t,i&&f){const t=a;a=()=>O(t())}const y=t=>{p=E.options.onStop=()=>{g(t,"watch cleanup")}};let S=n(c)?[]:m;const j=i?()=>{const t=E();(f||((t,e)=>!Object.is(t,e))(t,S))&&(p&&p(),w(i,"watch callback",[t,S===m?void 0:S,y]),S=t)}:void 0,k=b,E=function(t,n){t.effect&&(t=t.effect.fn);const o=new h(t);n&&(e(o,n),n.scope&&r(o,n.scope)),n&&n.lazy||o.run();const c=o.run.bind(o);return c.effect=o,c}(a,{lazy:!0,onTrack:l,onTrigger:u,scheduler:j?()=>k(j):k});j?s?j():S=E():E();const T=function(){!function(t){t.effect.stop()}(E)};return T.effect=E,T}function O(t,e=new Set){if(!c(t)||e.has(t))return t;if(e.add(t),n(t))for(let n=0;n<t.length;n++)O(t[n],e);else if(t instanceof Map)t.forEach(((n,o)=>{O(t.get(o),e)}));else if(t instanceof Set)t.forEach((t=>{O(t,e)}));else for(const n of Object.keys(t))O(t[n],e);return t}export{j as watch,S as watchEffect};
