!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).PetiteWatch={})}(this,(function(t){"use strict";const e=()=>{},n=Object.assign,o=Array.isArray,c=t=>"function"==typeof t,i=t=>null!==t&&"object"==typeof t;function r(t,e){(e=e||undefined)&&e.active&&e.effects.push(t)}const s=t=>(t.w&u)>0,f=t=>(t.n&u)>0;let l=0,u=1;const a=[];let h;class d{constructor(t,e=null,n){this.fn=t,this.scheduler=e,this.active=!0,this.deps=[],r(this,n)}run(){if(!this.active)return this.fn();if(!a.includes(this))try{return a.push(h=this),u=1<<++l,l<=30?(({deps:t})=>{if(t.length)for(let e=0;e<t.length;e++)t[e].w|=u})(this):p(this),this.fn()}finally{l<=30&&(t=>{const{deps:e}=t;if(e.length){let n=0;for(let o=0;o<e.length;o++){const c=e[o];s(c)&&!f(c)?c.delete(t):e[n++]=c,c.w&=~u,c.n&=~u}e.length=n}})(this),u=1<<--l,a.pop();const t=a.length;h=t>0?a[t-1]:void 0}}stop(){this.active&&(p(this),this.onStop&&this.onStop(),this.active=!1)}}function p(t){const{deps:e}=t;if(e.length){for(let n=0;n<e.length;n++)e[n].delete(t);e.length=0}}function g(t){return function(t){return!(!t||!t.__v_isReadonly)}(t)?g(t.__v_raw):!(!t||!t.__v_isReactive)}function v(t){return Boolean(t&&!0===t.__v_isRef)}function y(t,e,n){let o;try{o=n?t(...n):t()}catch(c){b(c,e)}return o}function w(t,e,n){if(c(t)){const r=y(t,e,n);return r&&(i(o=r)&&c(o.then)&&c(o.catch))&&r.catch((t=>{b(t,e)})),r}var o;const r=[];for(let c=0;c<t.length;c++)r.push(w(t[c],e,n));return r}function b(t,e){console.error(new Error(`[@vue-reactivity/watch]: ${e}`)),console.error(t)}function _(t){console.warn(function(t){return new Error(`[reactivue]: ${t}`)}(t))}new Set(Object.getOwnPropertyNames(Symbol).map((t=>Symbol[t])).filter((t=>"symbol"==typeof t))),Promise.resolve();const m=t=>t(),S={};function j(t,i,{immediate:s,deep:f,onTrack:l,onTrigger:u}={}){let a,h;if(o(t)&&!g(t)?a=()=>t.map((t=>v(t)?t.value:g(t)?T(t):c(t)?y(t,"watch getter"):void _("invalid source"))):v(t)?a=()=>t.value:g(t)?(a=()=>t,f=!0):a=c(t)?i?()=>y(t,"watch getter"):()=>(h&&h(),y(t,"watch callback",[p])):e,i&&f){const t=a;a=()=>T(t())}const p=t=>{h=k.options.onStop=()=>{y(t,"watch cleanup")}};let b=o(t)?[]:S;const j=i?()=>{const t=k();(f||((t,e)=>!Object.is(t,e))(t,b))&&(h&&h(),w(i,"watch callback",[t,b===S?void 0:b,p]),b=t)}:void 0,O=m,k=function(t,e){t.effect&&(t=t.effect.fn);const o=new d(t);e&&(n(o,e),e.scope&&r(o,e.scope)),e&&e.lazy||o.run();const c=o.run.bind(o);return c.effect=o,c}(a,{lazy:!0,onTrack:l,onTrigger:u,scheduler:j?()=>O(j):O});j?s?j():b=k():k();const E=function(){!function(t){t.effect.stop()}(k)};return E.effect=k,E}function T(t,e=new Set){if(!i(t)||e.has(t))return t;if(e.add(t),o(t))for(let n=0;n<t.length;n++)T(t[n],e);else if(t instanceof Map)t.forEach(((n,o)=>{T(t.get(o),e)}));else if(t instanceof Set)t.forEach((t=>{T(t,e)}));else for(const n of Object.keys(t))T(t[n],e);return t}t.watch=function(t,e,n){return j(t,e,n)},t.watchEffect=function(t,e){return j(t,null,e)},Object.defineProperty(t,"__esModule",{value:!0}),t[Symbol.toStringTag]="Module"}));
