var PetiteWatch=function(t){"use strict";const e=()=>{},n=Object.assign,o=Array.isArray,c=t=>"function"==typeof t,r=t=>null!==t&&"object"==typeof t;function i(t,e){(e=e||undefined)&&e.active&&e.effects.push(t)}const s=t=>(t.w&u)>0,f=t=>(t.n&u)>0;let l=0,u=1;const a=[];let h;class p{constructor(t,e=null,n){this.fn=t,this.scheduler=e,this.active=!0,this.deps=[],i(this,n)}run(){if(!this.active)return this.fn();if(!a.includes(this))try{return a.push(h=this),u=1<<++l,l<=30?(({deps:t})=>{if(t.length)for(let e=0;e<t.length;e++)t[e].w|=u})(this):d(this),this.fn()}finally{l<=30&&(t=>{const{deps:e}=t;if(e.length){let n=0;for(let o=0;o<e.length;o++){const c=e[o];s(c)&&!f(c)?c.delete(t):e[n++]=c,c.w&=~u,c.n&=~u}e.length=n}})(this),u=1<<--l,a.pop();const t=a.length;h=t>0?a[t-1]:void 0}}stop(){this.active&&(d(this),this.onStop&&this.onStop(),this.active=!1)}}function d(t){const{deps:e}=t;if(e.length){for(let n=0;n<e.length;n++)e[n].delete(t);e.length=0}}function v(t){return function(t){return!(!t||!t.__v_isReadonly)}(t)?v(t.__v_raw):!(!t||!t.__v_isReactive)}function g(t){return Boolean(t&&!0===t.__v_isRef)}function w(t,e,n){let o;try{o=n?t(...n):t()}catch(c){_(c,e)}return o}function y(t,e,n){if(c(t)){const i=w(t,e,n);return i&&(r(o=i)&&c(o.then)&&c(o.catch))&&i.catch((t=>{_(t,e)})),i}var o;const i=[];for(let c=0;c<t.length;c++)i.push(y(t[c],e,n));return i}function _(t,e){console.error(new Error(`[@vue-reactivity/watch]: ${e}`)),console.error(t)}function b(t){console.warn(function(t){return new Error(`[reactivue]: ${t}`)}(t))}new Set(Object.getOwnPropertyNames(Symbol).map((t=>Symbol[t])).filter((t=>"symbol"==typeof t))),Promise.resolve();const m=t=>t(),S={};function j(t,r,{immediate:s,deep:f,onTrack:l,onTrigger:u}={}){let a,h;if(o(t)&&!v(t)?a=()=>t.map((t=>g(t)?t.value:v(t)?O(t):c(t)?w(t,"watch getter"):void b("invalid source"))):g(t)?a=()=>t.value:v(t)?(a=()=>t,f=!0):a=c(t)?r?()=>w(t,"watch getter"):()=>(h&&h(),w(t,"watch callback",[d])):e,r&&f){const t=a;a=()=>O(t())}const d=t=>{h=E.options.onStop=()=>{w(t,"watch cleanup")}};let _=o(t)?[]:S;const j=r?()=>{const t=E();(f||((t,e)=>!Object.is(t,e))(t,_))&&(h&&h(),y(r,"watch callback",[t,_===S?void 0:_,d]),_=t)}:void 0,k=m,E=function(t,e){t.effect&&(t=t.effect.fn);const o=new p(t);e&&(n(o,e),e.scope&&i(o,e.scope)),e&&e.lazy||o.run();const c=o.run.bind(o);return c.effect=o,c}(a,{lazy:!0,onTrack:l,onTrigger:u,scheduler:j?()=>k(j):k});j?s?j():_=E():E();const T=function(){!function(t){t.effect.stop()}(E)};return T.effect=E,T}function O(t,e=new Set){if(!r(t)||e.has(t))return t;if(e.add(t),o(t))for(let n=0;n<t.length;n++)O(t[n],e);else if(t instanceof Map)t.forEach(((n,o)=>{O(t.get(o),e)}));else if(t instanceof Set)t.forEach((t=>{O(t,e)}));else for(const n of Object.keys(t))O(t[n],e);return t}return t.watch=function(t,e,n){return j(t,e,n)},t.watchEffect=function(t,e){return j(t,null,e)},Object.defineProperty(t,"__esModule",{value:!0}),t[Symbol.toStringTag]="Module",t}({});
